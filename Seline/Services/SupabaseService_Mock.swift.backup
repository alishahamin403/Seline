//
//  SupabaseService.swift
//  Seline
//
//  Recreated after accidental deletion.
//

import Foundation
import Combine
// import Supabase
// import Auth
// import PostgREST
// import Realtime

/// Minimal Supabase models used by the app. These mirror remote row shapes.
struct SupabaseEmail: Codable, Identifiable {
    let id: UUID
    let gmailID: String
    let userID: UUID
    let subject: String
    let senderName: String?
    let senderEmail: String
    let recipients: [[String: String]]
    let body: String
    let dateReceived: String // ISO8601 string
    let isRead: Bool
    let isImportant: Bool
    let labels: [String]
    let attachments: [[String: AnyCodable]]
    let isPromotional: Bool
    
    let syncedAt: String // ISO8601 string
}

/// Type-erased Codable for simple JSON payload passthrough
struct AnyCodable: Codable {
    let value: Any

    init(_ value: Any) { self.value = value }

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let intVal = try? container.decode(Int.self) { value = intVal; return }
        if let doubleVal = try? container.decode(Double.self) { value = doubleVal; return }
        if let boolVal = try? container.decode(Bool.self) { value = boolVal; return }
        if let stringVal = try? container.decode(String.self) { value = stringVal; return }
        if let dictVal = try? container.decode([String: AnyCodable].self) { value = dictVal; return }
        if let arrayVal = try? container.decode([AnyCodable].self) { value = arrayVal; return }
        value = NSNull()
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch value {
        case let intVal as Int: try container.encode(intVal)
        case let doubleVal as Double: try container.encode(doubleVal)
        case let boolVal as Bool: try container.encode(boolVal)
        case let stringVal as String: try container.encode(stringVal)
        case let dictVal as [String: AnyCodable]: try container.encode(dictVal)
        case let arrayVal as [AnyCodable]: try container.encode(arrayVal)
        default:
            try container.encodeNil()
        }
    }
}

/// Real-time connection status for Supabase subscriptions
enum RealtimeStatus: Equatable, CustomStringConvertible {
    case connected
    case connecting
    case disconnected
    case error(String)

    var description: String {
        switch self {
        case .connected: return "connected"
        case .connecting: return "connecting"
        case .disconnected: return "disconnected"
        case .error(let message): return "error(\(message))"
        }
    }
}

/// OAuth providers supported
enum OAuthProvider {
    case google
}

/// Supabase specific errors
enum SupabaseError: Error {
    case unexpectedResponse(String)
    case authenticationFailed
    case networkError(Error)
}

/// Supabase User model matching the users table
struct SupabaseUser: Codable, Identifiable {
    let id: UUID
    let email: String
    let name: String
    let profileImageURL: String?
    let googleID: String
    let accessToken: String?
    let refreshToken: String?
    let tokenExpirationDate: String? // ISO8601 string
    let createdAt: String
    let updatedAt: String
    let lastSignInAt: String?
    let isActive: Bool
    
    enum CodingKeys: String, CodingKey {
        case id, email, name, isActive
        case profileImageURL = "profile_image_url"
        case googleID = "google_id"
        case accessToken = "access_token"
        case refreshToken = "refresh_token"
        case tokenExpirationDate = "token_expiration_date"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case lastSignInAt = "last_sign_in_at"
    }
}

/// Core Supabase integration service (using HTTP requests for now)
class SupabaseService: ObservableObject {
    static let shared = SupabaseService()

    @Published private(set) var isConnected: Bool = true // Start as connected for development
    @Published private(set) var realtimeStatus: RealtimeStatus = .disconnected

    private var cancellables = Set<AnyCancellable>()
    private let isoFormatter: ISO8601DateFormatter = {
        let f = ISO8601DateFormatter()
        f.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return f
    }()
    
    // Supabase API configuration
    private let supabaseURL = "https://wnydlexwqtlhfbqdvwfj.supabase.co"
    private let supabaseKey = "sb_secret_RDy96qozS3DnN3efjyP0_g_xCAjeyzK"

    private init() {
        ProductionLogger.logCoreDataEvent("SupabaseService initialized with HTTP client")
        
        // Test connection
        Task {
            await testConnection()
        }
    }
    
    private func testConnection() async {
        do {
            let url = URL(string: "\(supabaseURL)/rest/v1/users")!
            var request = URLRequest(url: url)
            request.setValue(supabaseKey, forHTTPHeaderField: "apikey")
            request.setValue("Bearer \(supabaseKey)", forHTTPHeaderField: "Authorization")
            
            let (_, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                await MainActor.run {
                    self.isConnected = true
                    ProductionLogger.logCoreDataEvent("✅ Supabase connection established")
                }
            } else {
                throw NSError(domain: "SupabaseService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Connection test failed"])
            }
        } catch {
            await MainActor.run {
                self.isConnected = false
                ProductionLogger.logAuthEvent("❌ Supabase connection failed: \(error)")
            }
        }
    }

    // MARK: - Authentication & User Management

    func signInWithOAuth(provider: OAuthProvider, accessToken: String, refreshToken: String) async throws {
        ProductionLogger.logAuthEvent("Supabase OAuth sign-in with provider: \(provider)")
        
        // For now, we'll handle OAuth externally and just track connection
        await MainActor.run { 
            self.isConnected = true 
            ProductionLogger.logAuthEvent("✅ OAuth session established with Supabase")
        }
    }

    func signOut() async throws {
        // Real implementation would call Supabase signOut
        ProductionLogger.logAuthEvent("Supabase sign-out")
        await MainActor.run {
            self.realtimeStatus = .disconnected
        }
    }
    
    /// Create or update user in Supabase after Google OAuth
    func upsertUser(selineUser: SelineUser) async throws -> SupabaseUser {
        ProductionLogger.logAuthEvent("[Supabase] Upserting user: \(selineUser.email)")
        
        // CRITICAL: Check user consent before storing any data in cloud
        let privacyManager = DataPrivacyManager.shared
        try privacyManager.validateTokenStoragePermission()
        
        let now = Date()
        let nowString = isoFormatter.string(from: now)
        let expirationDateString = selineUser.tokenExpirationDate.map { isoFormatter.string(from: $0) }
        
        // Encrypt tokens before storing in cloud - CRITICAL for security
        let tokenEncryption = TokenEncryption.shared
        let (encryptedAccessToken, encryptedRefreshToken) = try tokenEncryption.encryptUserTokens(
            accessToken: selineUser.accessToken,
            refreshToken: selineUser.refreshToken,
            userId: selineUser.id,
            email: selineUser.email
        )
        
        // Prepare user data for HTTP request with encrypted tokens
        let userData: [String: Any] = [
            "email": selineUser.email,
            "name": selineUser.name,
            "profile_image_url": selineUser.profileImageURL as Any,
            "google_id": selineUser.id,
            // Store properly encrypted tokens (not plaintext)
            "access_token_encrypted": encryptedAccessToken as Any,
            "refresh_token_encrypted": encryptedRefreshToken as Any,
            "token_expires_at": expirationDateString as Any,
            "updated_at": nowString,
            "last_sync_at": nowString
        ]
        
        do {
            let url = URL(string: "\(supabaseURL)/rest/v1/users")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue(supabaseKey, forHTTPHeaderField: "apikey")
            request.setValue("Bearer \(supabaseKey)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("return=representation", forHTTPHeaderField: "Prefer")
            
            request.httpBody = try JSONSerialization.data(withJSONObject: userData)
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse,
               httpResponse.statusCode == 201 || httpResponse.statusCode == 200 {
                
                if let responseData = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]],
                   let userData = responseData.first {
                    
                    // Create SupabaseUser from response
                    let supabaseUser = SupabaseUser(
                        id: UUID(uuidString: userData["id"] as? String ?? "") ?? UUID(),
                        email: userData["email"] as? String ?? selineUser.email,
                        name: userData["name"] as? String ?? selineUser.name,
                        profileImageURL: userData["profile_image_url"] as? String,
                        googleID: userData["google_id"] as? String ?? selineUser.id,
                        accessToken: userData["access_token_encrypted"] as? String,
                        refreshToken: userData["refresh_token_encrypted"] as? String,
                        tokenExpirationDate: userData["token_expires_at"] as? String,
                        createdAt: userData["created_at"] as? String ?? nowString,
                        updatedAt: userData["updated_at"] as? String ?? nowString,
                        lastSignInAt: userData["last_sync_at"] as? String,
                        isActive: true
                    )
                    
                    ProductionLogger.logAuthEvent("✅ [Supabase] User upserted successfully: \(supabaseUser.email)")
                    return supabaseUser
                }
            }
            
            throw SupabaseError.unexpectedResponse("Failed to upsert user")
        } catch {
            ProductionLogger.logAuthEvent("❌ [Supabase] User upsert failed: \(error)")
            throw error
        }
    }
    
    /// Get user by Google ID
    func getUserByGoogleID(_ googleID: String) async throws -> SupabaseUser? {
        ProductionLogger.logAuthEvent("[Supabase] Fetching user by Google ID: \(googleID)")
        
        do {
            let url = URL(string: "\(supabaseURL)/rest/v1/users?google_id=eq.\(googleID)")!
            var request = URLRequest(url: url)
            request.setValue(supabaseKey, forHTTPHeaderField: "apikey")
            request.setValue("Bearer \(supabaseKey)", forHTTPHeaderField: "Authorization")
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
               let responseData = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]],
               let userData = responseData.first {
                
                let user = SupabaseUser(
                    id: UUID(uuidString: userData["id"] as? String ?? "") ?? UUID(),
                    email: userData["email"] as? String ?? "",
                    name: userData["name"] as? String ?? "",
                    profileImageURL: userData["profile_image_url"] as? String,
                    googleID: userData["google_id"] as? String ?? googleID,
                    accessToken: userData["access_token_encrypted"] as? String,
                    refreshToken: userData["refresh_token_encrypted"] as? String,
                    tokenExpirationDate: userData["token_expires_at"] as? String,
                    createdAt: userData["created_at"] as? String ?? "",
                    updatedAt: userData["updated_at"] as? String ?? "",
                    lastSignInAt: userData["last_sync_at"] as? String,
                    isActive: true
                )
                
                ProductionLogger.logAuthEvent("✅ [Supabase] User found: \(user.email)")
                return user
            } else {
                ProductionLogger.logAuthEvent("ℹ️ [Supabase] User not found for Google ID: \(googleID)")
                return nil
            }
        } catch {
            ProductionLogger.logAuthEvent("❌ [Supabase] Failed to fetch user: \(error)")
            throw error
        }
    }
    
    /// Update user's last sign in timestamp
    func updateLastSignIn(userID: UUID) async throws {
        ProductionLogger.logAuthEvent("[Supabase] Updating last sign in for user: \(userID)")

        // For now, just log the update - HTTP PATCH would be more complex
        ProductionLogger.logAuthEvent("✅ [Supabase] Last sign in updated for user: \(userID)")
    }

    /// Update user tokens after refresh with proper encryption
    func updateUserTokens(userID: UUID, accessToken: String, refreshToken: String?, expirationDate: Date?, userId: String, email: String) async throws {
        let updatedAt = isoFormatter.string(from: Date())
        let expirationDateString = expirationDate.map { isoFormatter.string(from: $0) }

        ProductionLogger.logAuthEvent("[Supabase] Updating encrypted tokens for user: \(userID)")
        
        // Encrypt tokens before updating in cloud
        let tokenEncryption = TokenEncryption.shared
        let (encryptedAccessToken, encryptedRefreshToken) = try tokenEncryption.encryptUserTokens(
            accessToken: accessToken,
            refreshToken: refreshToken,
            userId: userId,
            email: email
        )
        
        // Real implementation would execute:
        // UPDATE users SET access_token_encrypted = $1, refresh_token_encrypted = $2, token_expires_at = $3, updated_at = $4 WHERE id = $5
        // With encrypted token values, not plaintext
        
        ProductionLogger.logAuthEvent("✅ [Supabase] Encrypted tokens updated for user: \(userID)")
    }
    
    /// Securely retrieve and decrypt user tokens from Supabase
    func getDecryptedUserTokens(userId: String, email: String) async throws -> (accessToken: String?, refreshToken: String?) {
        ProductionLogger.logAuthEvent("[Supabase] Retrieving encrypted tokens for user: \(userId)")
        
        // In real implementation, this would:
        // 1. Query Supabase for encrypted tokens by user ID
        // 2. Decrypt tokens using user-specific encryption key
        // 3. Return decrypted tokens for use
        
        // For now, return empty as this is a stub implementation
        // Real implementation would look like:
        /*
        guard let user = try await getUserByGoogleID(userId) else {
            throw SupabaseError.unexpectedResponse("User not found")
        }
        
        let tokenEncryption = TokenEncryption.shared
        let (decryptedAccessToken, decryptedRefreshToken) = try tokenEncryption.decryptUserTokens(
            encryptedAccessToken: user.accessToken,
            encryptedRefreshToken: user.refreshToken,
            userId: userId,
            email: email
        )
        
        return (decryptedAccessToken, decryptedRefreshToken)
        */
        
        return (nil, nil)
    }

    // MARK: - Email Sync

    /// Push Gmail emails to Supabase; returns count synced
    func syncEmailsToSupabase(_ emails: [Email], for userID: UUID) async throws -> Int {
        ProductionLogger.logCoreDataEvent("[Supabase] Syncing \(emails.count) emails for user \(userID)")
        
        guard !emails.isEmpty else { return 0 }
        
        var syncedCount = 0
        
        for _ in emails {
            // For now, just simulate the upsert - actual HTTP implementation would be more complex
            // In a full implementation, this would POST to /rest/v1/emails with conflict resolution
            
            // Simulate successful sync
            syncedCount += 1
        }
        
        ProductionLogger.logCoreDataEvent("✅ [Supabase] Synced \(syncedCount)/\(emails.count) emails")
        return syncedCount
    }

    /// Fetch recent emails for user from Supabase
    func fetchEmailsFromSupabase(for userID: UUID, limit: Int) async throws -> [SupabaseEmail] {
        // Real implementation would query Supabase via RPC / PostgREST
        ProductionLogger.logCoreDataEvent("[Supabase] Fetching up to \(limit) emails for user \(userID)")

        // Return empty for now; callers handle merge/update logic
        return []
    }

    /// Update email status flags in Supabase (read/important)
    func updateEmailStatus(
        gmailID: String,
        userID: UUID,
        isRead: Bool? = nil,
        isImportant: Bool? = nil
    ) async throws {
        // Real implementation would issue update to emails table
        var fields: [String] = []
        if let r = isRead { fields.append("isRead=\(r)") }
        if let i = isImportant { fields.append("isImportant=\(i)") }
        ProductionLogger.logCoreDataEvent("[Supabase] Update email \(gmailID) for user \(userID): \(fields.joined(separator: ", "))")

        // Notify listeners for cross-device sync
        notifyEmailUpdated()
    }

    /// PostgreSQL full-text search through Supabase
    func searchEmailsInSupabase(query: String, for userID: UUID, limit: Int) async throws -> [SupabaseEmail] {
        // Real implementation would call RPC or filtered select with to_tsvector query
        ProductionLogger.logCoreDataEvent("[Supabase] Search '\(query)' limit=\(limit) user=\(userID)")
        return []
    }

    /// Update sync status record in Supabase (analytics/telemetry)
    func updateSyncStatus(type: String, status: String, userID: UUID, metadata: [String: Any]?) async throws {
        ProductionLogger.logCoreDataEvent("[Supabase] Sync status: type=\(type) status=\(status) user=\(userID) meta=\(metadata != nil)")
        
        // For now, just log the sync status - full HTTP implementation would POST to /rest/v1/sync_status
        ProductionLogger.logCoreDataEvent("✅ [Supabase] Sync status recorded: type=\(type), status=\(status)")
        
        notifySyncUpdated()
    }

    // MARK: - Realtime

    func subscribeToEmailUpdates(userID: UUID) async throws {
        // Real implementation would subscribe to Realtime channel
        await MainActor.run { self.realtimeStatus = .connecting }
        // Simulate becoming connected shortly after
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
            self.realtimeStatus = .connected
            ProductionLogger.logCoreDataEvent("[Supabase] Realtime subscribed for user \(userID)")
        }
    }

    func unsubscribeFromUpdates() async {
        await MainActor.run { self.realtimeStatus = .disconnected }
        ProductionLogger.logCoreDataEvent("[Supabase] Realtime unsubscribed")
    }

    // MARK: - Notifications

    private func notifyEmailUpdated() {
        NotificationCenter.default.post(name: .supabaseEmailUpdated, object: nil)
    }

    private func notifySyncUpdated() {
        NotificationCenter.default.post(name: .supabaseSyncUpdated, object: nil)
    }
}




