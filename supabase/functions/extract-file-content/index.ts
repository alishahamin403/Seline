import \"jsr:@supabase/functions-js/edge-runtime.d.ts\";\nimport { createClient } from \"jsr:@supabase/supabase-js@2\";\n\nconst corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n  \"Access-Control-Allow-Headers\": \"authorization, x-client-info, apikey, content-type\",\n};\n\ninterface ExtractionRequest {\n  attachmentId: string;\n  storagePath: string;\n  fileName: string;\n  userId: string;\n}\n\ninterface ExtractedFields {\n  [key: string]: unknown;\n}\n\ninterface BankStatementExtraction {\n  accountNumber?: string;\n  accountNumberMasked?: string;\n  statementPeriodStart?: string;\n  statementPeriodEnd?: string;\n  openingBalance?: number;\n  closingBalance?: number;\n  totalDeposits?: number;\n  totalWithdrawals?: number;\n  transactionCount?: number;\n  interestEarned?: number;\n  feesCharged?: number;\n}\n\nDeno.serve(async (req: Request) => {\n  if (req.method === \"OPTIONS\") {\n    return new Response(\"ok\", { headers: corsHeaders });\n  }\n\n  try {\n    // Verify the request is coming from authenticated user\n    const authHeader = req.headers.get(\"authorization\");\n    if (!authHeader) {\n      return new Response(\n        JSON.stringify({ error: \"Missing authorization header\" }),\n        { status: 401, headers: corsHeaders }\n      );\n    }\n\n    const requestBody: ExtractionRequest = await req.json();\n    const { attachmentId, storagePath, fileName, userId } = requestBody;\n\n    console.log(`ðŸ“¨ Extracting file: ${fileName} (attachment: ${attachmentId})`);\n\n    // Initialize Supabase client\n    const supabaseUrl = Deno.env.get(\"SUPABASE_URL\");\n    const supabaseKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\");\n\n    if (!supabaseUrl || !supabaseKey) {\n      throw new Error(\"Missing Supabase credentials\");\n    }\n\n    const supabase = createClient(supabaseUrl, supabaseKey);\n\n    // Download file from storage\n    const { data: fileData, error: downloadError } = await supabase.storage\n      .from(\"note-attachments\")\n      .download(storagePath);\n\n    if (downloadError) {\n      throw new Error(`Failed to download file: ${downloadError.message}`);\n    }\n\n    // Convert file to format for Claude\n    const fileContent = await convertFileContent(fileData as Blob, fileName);\n    const documentType = detectDocumentType(fileName);\n\n    // Call Claude API to extract information\n    const apiKey = Deno.env.get(\"ANTHROPIC_API_KEY\");\n    if (!apiKey) {\n      throw new Error(\"Missing Anthropic API key\");\n    }\n\n    const extractedData = await extractWithClaude(\n      fileContent,\n      documentType,\n      apiKey\n    );\n\n    // Store extracted data in database\n    const { error: insertError } = await supabase\n      .from(\"extracted_data\")\n      .insert([\n        {\n          id: crypto.randomUUID(),\n          user_id: userId,\n          attachment_id: attachmentId,\n          document_type: documentType,\n          extracted_fields: extractedData.fields,\n          raw_text: extractedData.rawText,\n          confidence: extractedData.confidence,\n          is_edited: false,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        },\n      ]);\n\n    if (insertError) {\n      throw new Error(`Failed to store extracted data: ${insertError.message}`);\n    }\n\n    // Update attachment with document type\n    const { error: updateError } = await supabase\n      .from(\"attachments\")\n      .update({ document_type: documentType, updated_at: new Date().toISOString() })\n      .eq(\"id\", attachmentId);\n\n    if (updateError) {\n      console.error(`Warning: Failed to update attachment: ${updateError.message}`);\n    }\n\n    console.log(`âœ… Successfully extracted data from ${fileName}`);\n\n    return new Response(\n      JSON.stringify({\n        success: true,\n        documentType,\n        fieldsCount: Object.keys(extractedData.fields).length,\n      }),\n      {\n        status: 200,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Extraction error:\", error);\n    return new Response(\n      JSON.stringify({\n        error: error instanceof Error ? error.message : \"Unknown error occurred\",\n      }),\n      { status: 500, headers: corsHeaders }\n    );\n  }\n});\n\nasync function convertFileContent(\n  file: Blob,\n  fileName: string\n): Promise<FileContent> {\n  const ext = fileName.split(\".\").pop()?.toLowerCase() || \"\";\n\n  if ([\"pdf\", \"jpg\", \"jpeg\", \"png\", \"gif\"].includes(ext)) {\n    // Convert image/PDF to base64\n    const arrayBuffer = await file.arrayBuffer();\n    const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n    return {\n      type: \"image\",\n      data: base64,\n      mediaType: getMediaType(ext),\n    };\n  } else if ([\"csv\", \"txt\"].includes(ext)) {\n    // Text files\n    const text = await file.text();\n    return {\n      type: \"text\",\n      data: text,\n    };\n  } else {\n    throw new Error(`Unsupported file type: ${ext}`);\n  }\n}\n\ninterface FileContent {\n  type: \"image\" | \"text\";\n  data: string;\n  mediaType?: string;\n}\n\nfunction getMediaType(ext: string): string {\n  const types: Record<string, string> = {\n    pdf: \"application/pdf\",\n    jpg: \"image/jpeg\",\n    jpeg: \"image/jpeg\",\n    png: \"image/png\",\n    gif: \"image/gif\",\n  };\n  return types[ext] || \"application/octet-stream\";\n}\n\nfunction detectDocumentType(fileName: string): string {\n  const lowerName = fileName.toLowerCase();\n  if (\n    lowerName.includes(\"bank\") ||\n    lowerName.includes(\"statement\") ||\n    lowerName.includes(\"account\")\n  ) {\n    return \"bank_statement\";\n  } else if (\n    lowerName.includes(\"invoice\") ||\n    lowerName.includes(\"bill\")\n  ) {\n    return \"invoice\";\n  } else if (\n    lowerName.includes(\"receipt\") ||\n    lowerName.includes(\"order\")\n  ) {\n    return \"receipt\";\n  }\n  return \"document\";\n}\n\nasync function extractWithClaude(\n  fileContent: FileContent,\n  documentType: string,\n  apiKey: string\n): Promise<{\n  fields: ExtractedFields;\n  rawText: string;\n  confidence: number;\n}> {\n  const prompt = getExtractionPrompt(documentType);\n\n  // Prepare message content based on file type\n  const messageContent: unknown[] = [];\n\n  if (fileContent.type === \"image\" && fileContent.mediaType) {\n    messageContent.push({\n      type: \"image\",\n      source: {\n        type: \"base64\",\n        media_type: fileContent.mediaType,\n        data: fileContent.data,\n      },\n    });\n  } else {\n    messageContent.push({\n      type: \"text\",\n      text: fileContent.data,\n    });\n  }\n\n  messageContent.push({\n    type: \"text\",\n    text: prompt,\n  });\n\n  // Call Claude API\n  const response = await fetch(\"https://api.anthropic.com/v1/messages\", {\n    method: \"POST\",\n    headers: {\n      \"x-api-key\": apiKey,\n      \"anthropic-version\": \"2023-06-01\",\n      \"content-type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      model: \"claude-3-5-sonnet-20241022\",\n      max_tokens: 2000,\n      messages: [\n        {\n          role: \"user\",\n          content: messageContent,\n        },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Claude API error: ${response.status} - ${errorText}`);\n  }\n\n  const data = await response.json() as unknown;\n  const result = data as Record<string, unknown>;\n  const content = (result.content as Record<string, unknown>[]) || [];\n  const textBlock = content[0] as Record<string, unknown> | undefined;\n  const responseText = (textBlock?.text as string) || \"\";\n\n  // Parse JSON response from Claude\n  const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n  if (!jsonMatch) {\n    throw new Error(\"Failed to extract JSON from Claude response\");\n  }\n\n  const parsed = JSON.parse(jsonMatch[0]);\n  return {\n    fields: parsed.fields || {},\n    rawText: parsed.rawText || \"\",\n    confidence: parsed.confidence || 0.8,\n  };\n}\n\nfunction getExtractionPrompt(documentType: string): string {\n  const basePrompt = `Extract structured information from the provided ${documentType}. \nReturn a JSON object with the following structure:\n{\n  \"fields\": { /* extracted key-value pairs */ },\n  \"rawText\": \"Full raw text from the document\",\n  \"confidence\": 0.95\n}`;\n\n  const typeSpecificPrompts: Record<string, string> = {\n    bank_statement: `Extract the following fields from the bank statement:\n- accountNumber (masked as ****XXXX)\n- statementPeriodStart (ISO date)\n- statementPeriodEnd (ISO date)\n- openingBalance (number)\n- closingBalance (number)\n- totalDeposits (number)\n- totalWithdrawals (number)\n- transactionCount (number)\n- interestEarned (number)\n- feesCharged (number)\n- transactions (array with date, description, amount, type fields)\n\nReturn JSON format as shown above.`,\n    invoice: `Extract the following fields from the invoice:\n- vendorName\n- invoiceNumber\n- invoiceDate (ISO date)\n- dueDate (ISO date)\n- lineItems (array with description, quantity, unitPrice, totalPrice)\n- subtotal (number)\n- taxAmount (number)\n- totalAmount (number)\n- paymentTerms\n\nReturn JSON format as shown above.`,\n    receipt: `Extract the following fields from the receipt:\n- merchantName\n- transactionDate (ISO date)\n- transactionTime\n- items (array with description, quantity, price)\n- subtotal (number)\n- tax (number)\n- totalPaid (number)\n- paymentMethod\n\nReturn JSON format as shown above.`,\n  };\n\n  return (\n    typeSpecificPrompts[documentType] ||\n    basePrompt\n  );\n}\n